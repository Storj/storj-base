#! /usr/bin/env node

'use strict';

const _ = require('lodash');
const fs = require('fs');
const path = require('path');

const error = console.error.bind(this);
const log = console.log.bind(this);
const info = console.info.bind(this);

const shell = require('shelljs');
const entryPwd = shell.pwd().stdout;

function init(currentDir) {
  const pwd = shell.pwd().stdout;
  currentDir = currentDir || '.';
  shell.cd(currentDir);

  // -- recurse
  submodules().forEach(function(submodule) {
    gitSubmoduleInit(submodule);
    gitSubmoduleUpdate(submodule);
    init(submodule)
  });

  npmLinkSubmodules(path.join(pwd, currentDir));
  shell.cd(pwd);
}

function gitSubmoduleInit(submodule) {
  submodule = submodule || '.';
  shell.exec('git submodule init ' + submodule);
}

function gitSubmoduleUpdate(submodule) {
  submodule = submodule || '.';
  shell.exec('git submodule update ' + submodule);
}

function npmLinkSubmodules(currentDir) {
  submodules().forEach(function(submodule) {

    try {
      const module = JSON.parse(fs.readFileSync(path.join(currentDir, submodule, 'package.json')));
      const source = path.join(currentDir, submodule)
      const target = path.join(currentDir, 'node_modules', module.name)
      // TODO: add confirmation prompt here before delete
      shell.exec('rm -rf ' + target)
      // TODO: Check if module is already linked
      // Error if it is and it's a different refspect or commit hash
      shell.exec('ln -s ' + source + ' ' + target)
      shell.exec('cd ' + submodule + ' && yarn install --ignore-engines');
    } catch (err) {
      // error(err.message);
      // error(err.stack);
      throw new Error(err);
    }
  })
}

function submodules() {
  return _.compact(
    shell
      .exec('git submodule')
      .stdout
      .split('\n')
      .map(function(line) {
        if (/(^\s*$)|(storj-base)/.test(line)) return;

        return line.match(/.\w+\s(\S+)/)[1];
      })
  )
}

exports.init = init;
